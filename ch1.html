<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>掌控 RISC-V - 用 Rust 编写一个 RISC-V 操作系统</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">前言</a></li><li class="chapter-item expanded affix "><a href="ch0.html">环境配置与依赖安装</a></li><li class="chapter-item expanded "><a href="ch1.html" class="active"><strong aria-hidden="true">1.</strong> 掌控 RISC-V</a></li><li class="chapter-item expanded "><a href="ch2.html"><strong aria-hidden="true">2.</strong> 通信</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> 内存管理</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch3.1.html"><strong aria-hidden="true">3.1.</strong> 页粒度的内存分配</a></li><li class="chapter-item expanded "><a href="ch3.2.html"><strong aria-hidden="true">3.2.</strong> 内存管理单元</a></li></ol></li><li class="chapter-item expanded "><a href="ch4.html"><strong aria-hidden="true">4.</strong> 处理中断和陷入</a></li><li class="chapter-item expanded "><a href="ch5.html"><strong aria-hidden="true">5.</strong> 外部中断</a></li><li class="chapter-item expanded "><a href="ch6.html"><strong aria-hidden="true">6.</strong> 进程的内存</a></li><li class="chapter-item expanded "><a href="ch7.html"><strong aria-hidden="true">7.</strong> 系统调用</a></li><li class="chapter-item expanded "><a href="ch8.html"><strong aria-hidden="true">8.</strong> 启动一个进程</a></li><li class="chapter-item expanded "><a href="ch9.html"><strong aria-hidden="true">9.</strong> 块设备驱动</a></li><li class="chapter-item expanded "><a href="ch10.html"><strong aria-hidden="true">10.</strong> 文件系统</a></li><li class="chapter-item expanded "><a href="ch11.html"><strong aria-hidden="true">11.</strong> 用户空间进程</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">用 Rust 编写一个 RISC-V 操作系统</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="掌控-risc-v"><a class="header" href="#掌控-risc-v">掌控 RISC-V</a></h1>
<p>这是<a href="http://osblog.stephenmarz.com/index.html">用 Rust 编写 RISC-V 操作系统</a>系列教程中的第 1 章。</p>
<p><a href="index.html">目录</a> → <a href="ch0.html">第 0 章</a> → 第 1 章 → <a href="ch2.html">第 2 章</a></p>
<p><strong><span style='color:red'>2019年9月27日</span></strong></p>
<h2 id="概述"><a class="header" href="#概述">概述</a></h2>
<p>启动并进入 RISC-V 系统很简单。在各种方法中，我将要介绍我自己的方法——从物理内存地址 <code>0x8000_0000</code> 开始。幸运的是， QEMU 可以读取 ELF 文件，所以它知道应该把我们的代码运行在哪个地址上。在整个过程中，我们将通过查看 QEMU 中包含的<code>qemu/hw/riscv/virt.c</code>源代码来获取一些信息。首先，先来看一下内存映射：</p>
<pre><code class="language-c">static const struct MemmapEntry {
    hwaddr base;
    hwaddr size;
} virt_memmap[] = {
    [VIRT_DEBUG] =       {        0x0,         0x100 },
    [VIRT_MROM] =        {     0x1000,       0x11000 },
    [VIRT_TEST] =        {   0x100000,        0x1000 },
    [VIRT_CLINT] =       {  0x2000000,       0x10000 },
    [VIRT_PLIC] =        {  0xc000000,     0x4000000 },
    [VIRT_UART0] =       { 0x10000000,         0x100 },
    [VIRT_VIRTIO] =      { 0x10001000,        0x1000 },
    [VIRT_DRAM] =        { 0x80000000,           0x0 },
    [VIRT_PCIE_MMIO] =   { 0x40000000,    0x40000000 },
    [VIRT_PCIE_PIO] =    { 0x03000000,    0x00010000 },
    [VIRT_PCIE_ECAM] =   { 0x30000000,    0x10000000 },
};
</code></pre>
<p>由此可见，我们的机器从 DRAM(VIRT_DRAM) 的第0字节，地址 0x8000_0000 开始。当我们再往前走一点，我们将对CLINT（0x200_0000）、PLIC（0xc00_0000）、UART（0x1000_0000）和VIRTIO（0x1000_1000）编程。现在不要担心这些是什么意思，我们只需要看看接下来要做什么!</p>
<p>完成这些后，我们需要在RISC-V汇编中完成以下工作：</p>
<ol>
<li>选择一个CPU引导加载程序（通常是id#0）；</li>
<li>将BSS部分清零；</li>
<li>开始Rust!</li>
</ol>
<p>RISC-V汇编类似于MIPS汇编，除了我们不需要给我们的寄存器加前缀。所有的指令都来自于RISC-V规范，你可以在以下网站获取：<a href="https://github.com/riscv/riscv-isa-manual">https://github.com/riscv/riscv-isa-manual</a>。我们的编写对象是RV64GC（RISC-V 64位，一般扩展和压缩指令扩展）。</p>
<h2 id="选择一个引导加载程序-bootloader"><a class="header" href="#选择一个引导加载程序-bootloader">选择一个引导加载程序 (bootloader)</a></h2>
<p>这个时候我们不考虑并行性、条件竞争或其他此类问题。相反，我们只让我们的一个CPU核心（RISC-V中称为HARTs[硬件线程]）做所有的工作。现在我们首先要深入研究特权级规范，来弄清我们要讨论的是哪个寄存器。因此，请在<a href="https://github.com/riscv/riscv-isa-manual/">https://github.com/riscv/riscv-isa-manual</a>下载。
我们将从3.1.5章中开始（Hart ID寄存器 mhartid）。这个寄存器将告诉我们我们的hart编号。根据规范，我们必须有一个hart id #0。所以，我们以这个ID来启动。</p>
<p>在你的<code>src/asm/</code>目录下创建一个<code>boot.S</code>文件。我们将在此启动并进入Rust的编写。</p>
<pre><code class="language-nasm"># boot.S
# bootloader for SoS
# Stephen Marz
# 8 February 2019
.option norvc
.section .data

.section .text.init
.global _start
_start:
    # Any hardware threads (hart) that are not bootstrapping
    # need to wait for an IPI
    csrr    t0, mhartid
    bnez    t0, 3f
    # SATP should be zero, but let's make sure
    csrw    satp, zero
.option push
.option norelax
    la      gp, _global_pointer
.option pop

3:
    wfi
    j   3b
</code></pre>
<p>这里csrr的意思是 &quot;控制状态寄存器读取&quot;，利用csrr我们把hart标识符读到寄存器t0中，检查它是否为零。如果不是，我们就把它送去循环等待。之后，我们将监管者地址转换和保护（satp）寄存器设置为0，这就是我们最终控制MMU的方式。由于我们还没有对虚拟内存的需求，我们用csrw（控制状态寄存器写入）写入0来把它禁用掉。一些板子的复位向量会将mhartid加载到该板子的a0寄存器中，但有些板子或许不会这么做，所以我选择从最可靠的地方来获取hart ID。</p>
<h2 id="清除bss"><a class="header" href="#清除bss">清除BSS</a></h2>
<p>全局的、未初始化的变量的初值都是0，因为这些变量是在BSS段分配的。对于操作系统而言，我们要保证内存全是0。幸运的是，在我们的链接器脚本中定义了<code>_bss_start</code>和<code>_bss_end</code>这两个字段，分别告诉我们BSS部分的开始和结束位置。因此，我们在<code>.option pop</code>和<code>3</code>之间添加以下内容：</p>
<pre><code class="language-nasm"># The BSS section is expected to be zero
    la      a0, _bss_start
    la      a1, _bss_end
    bgeu    a0, a1, 2f
1:
    sd      zero, (a0)
    addi    a0, a0, 8
    bltu    a0, a1, 1b
2:
</code></pre>
<p>在这里，我们使用sd（双字[64位]存储）将0存到内存地址a0，该地址逐渐向_bss_end移动。</p>
<h3 id="进入rust编程"><a class="header" href="#进入rust编程">进入Rust编程</a></h3>
<p>由于许多人都不喜欢编写大量的汇编，我们尽快跳入Rust，虽然也会有人认为用Rust编程是最难的部分。我们的Rust不会那么难，不会一直和借用检查器(borrow checker)较劲。</p>
<p>为了进入Rust程序并使CPU处于一个确定的模式，我们将使用mret指令，这是一个陷入返回函数，允许我们将mstatus寄存器设置为我们的特权模式。因此，我们在boot.S中加入以下内容。</p>
<pre><code class="language-nasm"># Control registers, set the stack, mstatus, mepc,
# and mtvec to return to the main function.
    # li    t5, 0xffff;
    # csrw  medeleg, t5
    # csrw  mideleg, t5
    la      sp, _stack
# We use mret here so that the mstatus register
# is properly updated.
    li      t0, (0b11 &lt;&lt; 11) | (1 &lt;&lt; 7) | (1 &lt;&lt; 3)
    csrw    mstatus, t0
    la      t1, kmain
    csrw    mepc, t1
    la      t2, asm_trap_vector
    csrw    mtvec, t2
    li      t3, (1 &lt;&lt; 3) | (1 &lt;&lt; 7) | (1 &lt;&lt; 11)
    csrw    mie, t3
    la      ra, 4f
    mret
4:
    wfi
    j   4b
</code></pre>
<p>这段代码很长，中间还有些注释。我们要做的是将[12:11]位设置为11，也就是 &quot;机器模式(machine mode)&quot;。这将使我们能够访问所有的指令和寄存器。当然，我们或许已经处于这一模式了，但还是做一次比较好。</p>
<p>&gt; 之后位[7]和位[3]将在总体上启用中断。然而，我们仍然需要通过<code>mie</code>（机器中断使能）寄存器启用特定的中断，这一点在最后几行实现。</p>
<p>mepc寄存器是 &quot;机器异常程序计数器&quot;，它是我们要返回的内存地址。符号<code>kmain</code>是在Rust中定义的，是我们离开汇编、进入Rust的“逃生”通道。</p>
<p>mtvec（机器陷入向量）是一个内核函数，每当有陷入出现时就会被调用，比如系统调用、非法指令或者时钟中断。</p>
<p>在我们完成Rust的主函数后，我们将ra（返回地址）置为等待状态。然后，<code>mret</code>指令将我们刚才所做的一切，通过mepc寄存器跳回，这就是我们最终进入Rust的地方!</p>
<p>(2019年9月29日添加）我们已经参考了<code>asm_trap_vector</code>，但我们还没有实际编写它。不过我们很快就会开工，现在先在 <code>src/asm/</code> 下创建一个名为 <code>trap.S</code> 的文件，并在其中添加以下内容。</p>
<pre><code class="language-nasm"># trap.S
# Assembly-level trap handler.
.section .text
.global asm_trap_vector
asm_trap_vector:
    # We get here when the CPU is interrupted
    # for any reason.
    mret
</code></pre>
<h2 id="裸机-rust-的世界"><a class="header" href="#裸机-rust-的世界">裸机 Rust 的世界！</a></h2>
<p>现在我们已经进入了rust。首先我们需要编辑 <code>lib.rs</code>，这个文件是由cargo命令为我们创建的。不要改变 lib.rs 的名称，否则 cargo 将永远不知道我们在干什么。lib.rs将是我们的入口点与我们用来导入其他Rust模块的工具。不要把<code>kmain</code>看成是一段执行代码。相反，它将初始化我们所需要的一切，然后引起 &quot;大爆炸&quot;，也就是说让所有代码都开始运行。操作系统主要是异步的，我们将使用时钟中断来指示内核开始运行，所以我们不能使用平时习惯的单线程编程方法。</p>
<p>当第一次打开<code>lib.rs</code>时，清空文件，因为里面没有我们需要用于内核的东西。我们需要自己定义一些东西来满足Rust的要求。由于我们不会使用标准库（标准库自己就依赖于内核，不能被用于我们的内核构建），我们必须首先定义<code>abort</code>和<code>panic_handler</code>再去做别的事情。就像这样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Steve Operating System
// Stephen Marz
// 21 Sep 2019
#![no_std]
#![feature(panic_info_message,asm)]

// ///////////////////////////////////
// / RUST MACROS
// ///////////////////////////////////
#[macro_export]
macro_rules! print
{
    ($($args:tt)+) =&gt; ({

    });
}
#[macro_export]
macro_rules! println
{
    () =&gt; ({
        print!(&quot;\r\n&quot;)
    });
    ($fmt:expr) =&gt; ({
        print!(concat!($fmt, &quot;\r\n&quot;))
    });
    ($fmt:expr, $($args:tt)+) =&gt; ({
        print!(concat!($fmt, &quot;\r\n&quot;), $($args)+)
    });
}

// ///////////////////////////////////
// / LANGUAGE STRUCTURES / FUNCTIONS
// ///////////////////////////////////
#[no_mangle]
extern &quot;C&quot; fn eh_personality() {}
#[panic_handler]
fn panic(info: &amp;core::panic::PanicInfo) -&gt; ! {
    print!(&quot;Aborting: &quot;);
    if let Some(p) = info.location() {
        println!(
                    &quot;line {}, file {}: {}&quot;,
                    p.line(),
                    p.file(),
                    info.message().unwrap()
        );
    }
    else {
        println!(&quot;no information available.&quot;);
    }
    abort();
}
#[no_mangle]
extern &quot;C&quot;
fn abort() -&gt; ! {
    loop {
        unsafe {
            // The asm! syntax has changed in Rust.
            // For the old, you can use llvm_asm!, but the
            // new syntax kicks ass--when we actually get to use it.
            asm!(&quot;wfi&quot;);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>我们使用<code>#![no_std]</code>来告诉Rust不会使用标准库。然后我们要求Rust允许我们的代码使用 panic 信息和内嵌式汇编功能。第一件要做的事是创建一个空的<code>eh_personality</code>函数。<code>#[no_mangle]</code>关闭了Rust的名称处理功能，所以这个符号确实是eh_personality。然后，<code>extern &quot;C &quot;</code>告诉Rust使用C风格的ABI。</p>
<p>之后，<code>#[panic_handler]</code>告诉Rust，我们定义的下一个函数将是我们的panic处理程序。Rust调用panic有几个原因，我们将用我们的断言隐式地调用它。我让这个函数做的是打印出产生panic的源文件和行号。虽说我们还没有实现<code>print！</code>或<code>println!</code>，但我们知道Rust中print和println的格式。顺便提一下，<code>-&gt;！</code>意味着这个函数不会返回。如果Rust检测到它可以返回，编译器会报错。</p>
<p>最后，我们编写<code>abort</code>函数。它要做的就是不断循环<code>wfi</code>（等待中断）指令。这使它正在运行的hart关闭，直到另一个中断发生。</p>
<h3 id="我们真正进入了rust"><a class="header" href="#我们真正进入了rust">我们真正进入了RUST!</a></h3>
<p>我们已经正式进入rust，所以我们需要写出<code>boot.S</code>中指定的入口点，也就是<code>kmain</code>。所以，在我们的<code>lib.rs</code>代码中添加：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
extern &quot;C&quot;
fn kmain() {
    // Main should initialize all sub-systems and get
    // ready to start scheduling. The last thing this
    // should do is start the timer.
}
<span class="boring">}
</span></code></pre></pre>
<p>当kmain返回时，它碰到wfi循环并挂起。这是我们所期望的，因为我们还没有告诉内核要做什么。</p>
<p>那么基本已经完工了，我们进入了Rust之中。不幸的是，在我们实现<code>print！</code>之前不会看到任何打印到屏幕上的东西。但是，现在的代码至少应该是能够正常编译的！一般来说，优秀的作家会以一些引言或结束语来结束，但我并不是一位优秀的作家。</p>
<p>当你输入<code>make run</code>时，你的操作系统将尝试启动并进入Rust。然而由于我们还没有编写与操作系统通信的驱动程序，所以什么也不会发生。输入CTRL-A+'x'退出模拟器。同时，你也可以通过输入CTRL-A+'c'来查看你所在的位置。你现在是在QEMU的控制台。输入 &quot;info registers &quot;来查看模拟器在你的操作系统中的位置。</p>
<p><a href="ch0.html">第0章</a> → 第1章 → <a href="ch2.html">第2章</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch0.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch2.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ch0.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="ch2.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
