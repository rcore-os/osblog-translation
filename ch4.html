<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>处理中断和陷入 - 用 Rust 编写一个 RISC-V 操作系统</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="ch0.html">环境配置与依赖安装</a></li><li class="chapter-item expanded "><a href="ch1.html"><strong aria-hidden="true">1.</strong> 掌控 RISC-V</a></li><li class="chapter-item expanded "><a href="ch2.html"><strong aria-hidden="true">2.</strong> 通信</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> 内存管理</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch3.1.html"><strong aria-hidden="true">3.1.</strong> 页粒度的内存分配</a></li><li class="chapter-item expanded "><a href="ch3.2.html"><strong aria-hidden="true">3.2.</strong> 内存管理单元</a></li></ol></li><li class="chapter-item expanded "><a href="ch4.html" class="active"><strong aria-hidden="true">4.</strong> 处理中断和陷入</a></li><li class="chapter-item expanded "><a href="ch5.html"><strong aria-hidden="true">5.</strong> 外部中断</a></li><li class="chapter-item expanded "><a href="ch6.html"><strong aria-hidden="true">6.</strong> 进程的内存</a></li><li class="chapter-item expanded "><a href="ch7.html"><strong aria-hidden="true">7.</strong> 系统调用</a></li><li class="chapter-item expanded "><a href="ch8.html"><strong aria-hidden="true">8.</strong> 启动一个进程</a></li><li class="chapter-item expanded "><a href="ch9.html"><strong aria-hidden="true">9.</strong> 块设备驱动</a></li><li class="chapter-item expanded "><a href="ch10.html"><strong aria-hidden="true">10.</strong> 文件系统</a></li><li class="chapter-item expanded "><a href="ch11.html"><strong aria-hidden="true">11.</strong> 用户空间进程</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">用 Rust 编写一个 RISC-V 操作系统</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="处理中断和陷入"><a class="header" href="#处理中断和陷入">处理中断和陷入</a></h1>
<h2 id="概述"><a class="header" href="#概述">概述</a></h2>
<p>如果我们从来不会出差错，那不是很好吗？嗯，很不好，这是不可能的。所以，我们需要在问题发生时做好准备。 CPU 能够在事情发生时通知内核。虽说如此，并非所有的通知都是坏事。比如系统调用，或者定时器中断呢？是的，这些也会导致 CPU 通知内核。</p>
<h2 id="risc-v中断系统"><a class="header" href="#risc-v中断系统">RISC-V中断系统</a></h2>
<p>RISC-V 系统使用一个单一的、指向内核中的物理地址的函数指针。每当有事情发生时，CPU 会切换到机器态并跳转到这个函数。在 RISC-V 中，我们有两个特殊的 CSR（控制和状态寄存器）来控制这种 CPU 通信。</p>
<p>第一个寄存器是 <code>mtvec</code> 寄存器，它代表了机器陷入向量。向量是一个函数指针。每当有事情发生， CPU 就会“调用”这个寄存器所表示的函数。</p>
<p><img src="assets/4/mtvec.png" alt=" " /></p>
<p><code>mtvec</code> 寄存器有两个不同的字段。BASE ，也就是函数的地址，以及 MODE，它决定了我们是要使用直接中断还是向量中断。我们要使用 Rust 的 <code>match</code> 来重定向陷入。所以我们需要确保最后两位是 0 ，这意味着我们的函数地址需要是 4 的倍数。</p>
<p>使用直接模式的 <code>mtvec</code> 意味着所有的陷入都会进入完全相同的函数，而使用矢量模式的 <code>mtvec</code> 会根据陷入原因进入不同的函数。简单起见，我将使用直接模式。然后，我们可以使用 Rust 的 <code>match</code> 语句解析出陷入原因。</p>
<h2 id="为什么陷入"><a class="header" href="#为什么陷入">为什么陷入？</a></h2>
<p><code>mcause</code> 寄存器（机器态陷入原因）会给你一个异常代码，概括地解释是什么导致了陷入。陷入有两种不同的类型：异步的和同步的。异步陷入意味着是当前执行的指令之外的东西引起了 CPU 的“陷入”。同步陷入意味着是当前执行的指令引起了“陷入”。</p>
<p><img src="assets/4/mcause_async.png" alt=" " /></p>
<p>异步陷入的原因代码最高位一定为 1。</p>
<p><img src="assets/4/mcause_sync.png" alt=" " /></p>
<p>异步陷入的原因代码最高位一定为 0。</p>
<h2 id="简单启动"><a class="header" href="#简单启动">简单启动</a></h2>
<p>我对启动代码进行了修改以简化启动过程。我们通过 <code>kinit</code> 进入 Rust，它在仅有物理内存的机器态下运行代码。在这个函数中，我们基本上可以自任意支配我们的系统。然而， <code>kinit</code> 的意义在于让我们尽快进入 <code>kmain</code> 。我们将在内核态下运行 <code>kmain</code> 函数，在这种模式下，我们的内核开启了虚拟内存。</p>
<pre><code class="language-assembly"># We need a stack for our kernel. This symbol comes from virt.lds
la sp, _stack_end

# Setting `mstatus` register:
# 0b01 &lt;&lt; 11: Machine's previous protection mode is 2 (MPP=2).
li t0, 0b11 &lt;&lt; 11
csrw mstatus, t0

# Do not allow interrupts while running kinit
csrw mie, zero

# Machine's exception program counter (MEPC) is set to `kinit`.
la t1, kinit
csrw mepc, t1

# Set the return address to get us into supervisor mode
la ra, 2f

# We use mret here so that the mstatus register is properly updated.
mret
</code></pre>
<p>我们的代码设置好了机器态环境。我们在 <code>mie</code> 中写入 0，也就是“机器态中断使能寄存器”，以禁用所有的中断。因此， <code>kinit</code> 处于机器态，只有物理内存，并且现在是不可抢占的。这使我们能够设置我们的机器，而不必担心其他的硬件线程（核）会干扰我们的进程。</p>
<h2 id="陷入"><a class="header" href="#陷入">陷入</a></h2>
<p>陷入本质上是 CPU 通知内核的一种方式。通常情况下，我们作为内核程序员告诉 CPU 正在发生什么。然而，有时 CPU 需要让我们知道发生了什么。如上所述，它是通过一个陷入来实现的。所以，为了在 Rust 中处理陷入，我们需要创建一个新的文件， <code>trap.rs</code> 。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// trap.rs
// Trap routines
// Stephen Marz
// 10 October 2019

use crate::cpu::TrapFrame;

#[no_mangle]
extern &quot;C&quot; fn m_trap(epc: usize,
                     tval: usize,
                     cause: usize,
                     hart: usize,
                     status: usize,
                     frame: &amp;mut TrapFrame)
                     -&gt; usize
{
    // We're going to handle all traps in machine mode. RISC-V lets
    // us delegate to supervisor mode, but switching out SATP (virtual memory)
    // gets hairy.
    let is_async = {
        if cause &gt;&gt; 63 &amp; 1 == 1 {
            true
        }
        else {
            false
        }
    };
    // The cause contains the type of trap (sync, async) as well as the cause
    // number. So, here we narrow down just the cause number.
    let cause_num = cause &amp; 0xfff;
    let mut return_pc = epc;
    if is_async {
        // Asynchronous trap
        match cause_num {
            3 =&gt; {
                // Machine software
                println!(&quot;Machine software interrupt CPU#{}&quot;, hart);
            },
            7 =&gt; unsafe {
                // Machine timer
                let mtimecmp = 0x0200_4000 as *mut u64;
                let mtime = 0x0200_bff8 as *const u64;
                // The frequency given by QEMU is 10_000_000 Hz, so this sets
                // the next interrupt to fire one second from now.
                mtimecmp.write_volatile(mtime.read_volatile() + 10_000_000);
            },
            11 =&gt; {
                // Machine external (interrupt from Platform Interrupt Controller (PLIC))
                println!(&quot;Machine external interrupt CPU#{}&quot;, hart);
            },
            _ =&gt; {
                panic!(&quot;Unhandled async trap CPU#{} -&gt; {}\n&quot;, hart, cause_num);
            }
        }
    }
    else {
        // Synchronous trap
        match cause_num {
            2 =&gt; {
                // Illegal instruction
                panic!(&quot;Illegal instruction CPU#{} -&gt; 0x{:08x}: 0x{:08x}\n&quot;, hart, epc, tval);
            },
            8 =&gt; {
                // Environment (system) call from User mode
                println!(&quot;E-call from User mode! CPU#{} -&gt; 0x{:08x}&quot;, hart, epc);
                return_pc += 4;
            },
            9 =&gt; {
                // Environment (system) call from Supervisor mode
                println!(&quot;E-call from Supervisor mode! CPU#{} -&gt; 0x{:08x}&quot;, hart, epc);
                return_pc += 4;
            },
            11 =&gt; {
                // Environment (system) call from Machine mode
                panic!(&quot;E-call from Machine mode! CPU#{} -&gt; 0x{:08x}\n&quot;, hart, epc);
            },
            // Page faults
            12 =&gt; {
                // Instruction page fault
                println!(&quot;Instruction page fault CPU#{} -&gt; 0x{:08x}: 0x{:08x}&quot;, hart, epc, tval);
                return_pc += 4;
            },
            13 =&gt; {
                // Load page fault
                println!(&quot;Load page fault CPU#{} -&gt; 0x{:08x}: 0x{:08x}&quot;, hart, epc, tval);
                return_pc += 4;
            },
            15 =&gt; {
                // Store page fault
                println!(&quot;Store page fault CPU#{} -&gt; 0x{:08x}: 0x{:08x}&quot;, hart, epc, tval);
                return_pc += 4;
            },
            _ =&gt; {
                panic!(&quot;Unhandled sync trap CPU#{} -&gt; {}\n&quot;, hart, cause_num);
            }
        }
    };
    // Finally, return the updated program counter
    return_pc
}
<span class="boring">}
</span></code></pre></pre>
<p>上面的代码就是我们在陷入时跳转到的函数。CPU 遇到一个陷入，找到 <code>mtvec</code> ，然后跳转到其中指定的地址。注意，我们必须先解析出中断类型（异步或同步），然后再解析其原因。</p>
<p>请注意，我们有三个期望的同步异常： 8 、 9 和 11 。这些是“环境”调用，也就是系统调用。然而，原因是根据我们在发出 ecall 指令时所处的模式来解析的。我对机器态的 ecall 调用了 <code>panic!</code> ，因为我们永远不应该遇到一个机器态的 ecall 。相反，我们在内核态下运行内核，而用户应用程序将通过用户态的 ecall 进入内核。</p>
<p>当我们遇到一个陷入时，我们需要跟踪我们的寄存器等等。我们如果在一开始就搞乱了寄存器，就没有办法再重新启动一个用户应用。我们将把这些信息保存到一个叫做陷入帧的东西中。我们还将使用 <code>mscratch</code> 寄存器来存储这些信息，这样当我们遇到陷入的时候就很容易找到它。</p>
<h2 id="陷入帧-rust-结构体"><a class="header" href="#陷入帧-rust-结构体">陷入帧 Rust 结构体</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
#[derive(Clone, Copy)]
pub struct TrapFrame {
    pub regs:       [usize; 32], // 0 - 255
    pub fregs:      [usize; 32], // 256 - 511
    pub satp:       usize,       // 512 - 519
    pub trap_stack: *mut u8,     // 520
    pub hartid:     usize,       // 528
}
<span class="boring">}
</span></code></pre></pre>
<p>如上述结构体所示，我们存储了所有的通用寄存器、浮点寄存器、SATP（MMU）、处理陷入的堆栈，以及硬件线程 ID 。当我们只使用机器态的陷入时，最后一项是不必要的。RISC-V 允许我们将某些陷入委托给内核态。然而，我们还没有这样做。目前 <code>hartid</code> 是多余的，因为我们可以通过 <code>csrr a0, mhartid</code> 获得硬件线程 ID。</p>
<p>你还会注意到两个 Rust 指令： <code>#[repr(C)]</code> 和 <code>#[derive(Clone, Copy)]</code> 。第一个指令使我们的结构体遵循 C 语言风格的结构体。这么做是因为当我们在汇编中操作陷入帧时，我们需要知道每个成员变量的偏移量。最后， <code>derive</code> 指令将使 Rust 自动实现 <code>Copy</code> 和 <code>Clone</code> 的特性。如果我们不使用 <code>derive</code> ，我们就得自己实现。</p>
<p>现在我们已经建立起了陷入帧，让我们看看它在汇编中的样子。</p>
<h2 id="查看汇编中的陷入向量"><a class="header" href="#查看汇编中的陷入向量">查看汇编中的陷入向量</a></h2>
<pre><code class="language-assembly">.option norvc
m_trap_vector:
# All registers are volatile here, we need to save them
# before we do anything.
csrrw   t6, mscratch, t6
# csrrw will atomically swap t6 into mscratch and the old
# value of mscratch into t6. This is nice because we just
# switched values and didn't destroy anything -- all atomically!
# in cpu.rs we have a structure of:
#  32 gp regs       0
#  32 fp regs       256
#  SATP register    512
#  Trap stack       520
#  CPU HARTID       528
# We use t6 as the temporary register because it is the very
# bottom register (x31)
.set    i, 1
.rept   30
    save_gp %i
    .set    i, i+1
.endr

# Save the actual t6 register, which we swapped into
# mscratch
mv      t5, t6
csrr    t6, mscratch
save_gp 31, t5

# Restore the kernel trap frame into mscratch
csrw    mscratch, t5

# Get ready to go into Rust (trap.rs)
# We don't want to write into the user's stack or whomever
# messed with us here.
csrr    a0, mepc
csrr    a1, mtval
csrr    a2, mcause
csrr    a3, mhartid
csrr    a4, mstatus
mv      a5, t5
ld      sp, 520(a5)
call    m_trap

# When we get here, we've returned from m_trap, restore registers
# and return.
# m_trap will return the return address via a0.

csrw    mepc, a0

# Now load the trap frame back into t6
csrr    t6, mscratch

# Restore all GP registers
.set    i, 1
.rept   31
    load_gp %i
    .set    i, i+1
.endr

# Since we ran this loop 31 times starting with i = 1,
# the last one loaded t6 back to its original value.

mret
</code></pre>
<p>你可以看到我们使用了所谓的汇编器指令和宏，例如 <code>.set</code> 和 <code>store_gp</code> ，这使我们的生活更轻松。这本质上是一个汇编时的循环，当我们汇编这个文件时会被展开。</p>
<p>我们还指定了 <code>.option norvc</code> ，意思是&quot;RISC-V压缩指令&quot;，它是RISC-V ISA 的 C 扩展。这强制要求所有用于陷入向量的指令都是 32 位的。这不是特别重要，但是当我们添加多个陷入向量时，我们需要确保每个向量函数都从 4 的整数倍的内存地址开始。这是因为 <code>mtvec</code> 寄存器使用最后两位在直接模式和向量模式间切换。</p>
<h2 id="gnu-汇编宏"><a class="header" href="#gnu-汇编宏">GNU 汇编宏</a></h2>
<p>宏的定义如下。</p>
<pre><code class="language-assembly">.altmacro
.set NUM_GP_REGS, 32  # Number of registers per context
.set NUM_FP_REGS, 32
.set REG_SIZE, 8   # Register size (in bytes)
.set MAX_CPUS, 8   # Maximum number of CPUs

# Use macros for saving and restoring multiple registers
.macro save_gp i, basereg=t6
    sd  x\i, ((\i)*REG_SIZE)(\basereg)
.endm
.macro load_gp i, basereg=t6
    ld  x\i, ((\i)*REG_SIZE)(\basereg)
.endm
.macro save_fp i, basereg=t6
    fsd f\i, ((NUM_GP_REGS+(\i))*REG_SIZE)(\basereg)
.endm
.macro load_fp i, basereg=t6
    fld f\i, ((NUM_GP_REGS+(\i))*REG_SIZE)(\basereg)
.endm
</code></pre>
<p>讲解上面的宏已经超出了本博客的范围，但值得一提的是，我们正在执行以下指令之一： <code>sd, ld, fsd, fld</code> ，并且默认情况下，我们使用 <code>t6</code> 寄存器。我选择 <code>t6</code> 寄存器的原因是它是 31 号寄存器，这使得我们很容易追踪到我们从寄存器 0 一直运行到 31 的循环。</p>
<h2 id="这有什么作用"><a class="header" href="#这有什么作用">这有什么作用？</a></h2>
<p>陷入是由CPU引起的。每个硬件线程都可以产生陷入，所以我们之后需要进行互斥和推迟行动。</p>
<p>当你运行这段代码时，应该看到下面的输出。</p>
<p><img src="assets/4/ch4_output.png" alt=" " /></p>
<p>你会注意到，在底部有一个页面错误。这是有意为之，因为我已经在 Rust 代码中加入了以下内容。这几乎确保了页面错误的发生!</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
    // Set the next machine timer to fire.
    let mtimecmp = 0x0200_4000 as *mut u64;
    let mtime = 0x0200_bff8 as *const u64;
    // The frequency given by QEMU is 10_000_000 Hz, so this sets
    // the next interrupt to fire one second from now.
    mtimecmp.write_volatile(mtime.read_volatile() + 10_000_000);

    // Let's cause a page fault and see what happens. This should trap
    // to m_trap under trap.rs
    let v = 0x0 as *mut u64;
    v.write_volatile(0);
}
<span class="boring">}
</span></code></pre></pre>
<p>第一部分重置了CLINT定时器，这将触发一个异步机器定时器陷入。然后，我们对 NULL 指针解引用，这将导致我们的存储页面错误。如果是 <code>v.read_volatile()</code> ，我们会得到一个载入页面错误而非存储。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch3.2.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch5.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ch3.2.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="ch5.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
